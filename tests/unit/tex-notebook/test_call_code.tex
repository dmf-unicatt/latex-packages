\documentclass[oneside]{book}
\usepackage{tests-tex-notebook}

\begin{document}

\chapter{Testing the python function \texttt{call\_code}}

This file tests the python function \texttt{call\_code}, which is defined internally the package.

First of all we define a list that will contain all codes we test, and the local variables they define. These objects mimick the internal implementation used in the package, but choosing different variable names in order not to overlap.

\begin{pycell}
all_codes = []
local_variables = {}
\end{pycell}

Then we run several tests.

\begin{pycell}
cell_output, cell_figure_path = call_code(
"""
x = 1
y = 2
""",
all_codes, local_variables, pytex)
assert len(all_codes) == 1
assert (
    all_codes[0] == """
x = 1
y = 2
"""
)
assert cell_output == ""
assert cell_figure_path is None
assert "cell_output" not in local_variables
assert "cell_figure_path" not in local_variables
assert "x" in local_variables
assert "y" in local_variables
assert local_variables["x"] == 1
assert local_variables["y"] == 2
\end{pycell}

\begin{pycell}
cell_output, cell_figure_path = call_code(
"""
z = 3; n = 4
"""
,
all_codes, local_variables, pytex)
assert len(all_codes) == 2
assert (
    all_codes[0] == """
x = 1
y = 2
"""
)
assert (
    all_codes[1] == """
z = 3; n = 4
"""
)
assert cell_output == ""
assert cell_figure_path is None
assert "cell_output" not in local_variables
assert "cell_figure_path" not in local_variables
assert "x" in local_variables  # previous variables are kept
assert "y" in local_variables
assert "z" in local_variables
assert "n" in local_variables
assert local_variables["x"] == 1
assert local_variables["y"] == 2
assert local_variables["z"] == 3
assert local_variables["n"] == 4
\end{pycell}

\begin{pycell}
cell_output, _ = call_code(
"""
print(x + y + z + n)
"""
,
all_codes, local_variables, pytex)
assert cell_output == "10"
\end{pycell}

\begin{pycell}
cell_output, _ = call_code(
"""
x + y + z + n
"""
,
all_codes, local_variables, pytex)
assert cell_output == "10"
\end{pycell}

\begin{pycell}
cell_output, _ = call_code(
"""
print(x + y + z + n + 1)
x + y + z + n + 2
"""
,
all_codes, local_variables, pytex)
assert cell_output == "11\n12"
\end{pycell}

\begin{pycell}
cell_output, _ = call_code(
"""
x = "one"
y = "two two"
"""
,
all_codes, local_variables, pytex)
assert cell_output == ""
\end{pycell}

\begin{pycell}
cell_output, _ = call_code(
"""
z = "three THREE_Three"; n = "FoUr_four quattro_cuatro"
"""
,
all_codes, local_variables, pytex)
assert cell_output == ""
\end{pycell}

\begin{pycell}
cell_output, _ = call_code(
"""
" ".join([x, y, z, n])
"""
,
all_codes, local_variables, pytex)
assert cell_output == (
    "'one two two three THREE_Three FoUr_four quattro_cuatro'"
)
\end{pycell}

\begin{pycell}
cell_output, _ = call_code(
"""
print(" ".join([x, y]))
print(" ".join([z, n]))
"""
,
all_codes, local_variables, pytex)
assert cell_output == (
    "one two two\nthree THREE_Three FoUr_four quattro_cuatro"
)
\end{pycell}

\begin{pycell}
try:
    call_code(
"""
raise RuntimeError("a runtime error")
"""
,
all_codes, local_variables, pytex)
except RuntimeError as e:
    assert str(e) == "a runtime error"
else:
    assert False, "This should have failed"
\end{pycell}

\begin{pycell}
cell_output, cell_figure_path = call_code(
"""
import plotly.express as px
fig = px.scatter(x=[1, 2, 3], y=[4, 5, 6])
fig
"""
,
all_codes, local_variables, pytex)
assert cell_output == ""
assert cell_figure_path == (
    "pythontex-files-test_call_code/py_default_1_79.png"
)
\end{pycell}

Notebooks are automatically produced from this file, but they would not be runnable because they would miss the definition of \texttt{call\_code}, which is defined internally by this package. This is not really the point of this test, so we simply mock \texttt{save\_cells\_as\_notebook}, also defined internally by this package, to write a mock notebook instead of the actual one.

\begin{pycell}
original_save_cells_as_notebook = save_cells_as_notebook

def save_cells_as_notebook(
    all_cells: list[str], pytex: any
) -> None:
    return original_save_cells_as_notebook(
        ["\n# This notebook was disabled"], pytex
    )
\end{pycell}

\end{document}
