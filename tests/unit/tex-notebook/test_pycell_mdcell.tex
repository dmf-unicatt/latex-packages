\documentclass[oneside]{book}
\usepackage{tests-tex-notebook}

\begin{document}

\chapter{Case with numbers}

\begin{mdcell}
We start from *the most simple* case possible, the case of numbers.

Note that this content is typed in markdown, and then converted to LaTeX via the `markdown` package.
\end{mdcell}

\begin{pycell}
x = 1
y = 2
\end{pycell}

\begin{pycell}
z = 3; n = 4
\end{pycell}

\begin{pycell}
l = 6
m = 7
\end{pycell}

\begin{mdcell}
We can print a linear combination of the provided number from a pycell, either directly...
\end{mdcell}

\begin{pycell}
print(x + y + z + n - l - m)
\end{pycell}
\begin{pyexpectedoutput}
-3
\end{pyexpectedoutput}

\begin{mdcell}
... implicitly ...
\end{mdcell}

\begin{pycell}
x + y + z + n - l - m
\end{pycell}
\begin{pyexpectedoutput}
-3
\end{pyexpectedoutput}

\begin{mdcell}
... or in both ways (with duplicated output)
\end{mdcell}

\begin{pycell}
print(x + y + z + n - l - m + 1)
x + y + z + n - l - m + 2
\end{pycell}
\begin{pyexpectedoutput}
-2
-1
\end{pyexpectedoutput}

\begin{mdcell}
One can also print lists of numbers
\end{mdcell}

\begin{pycell}
x = [1, 2, 3]
y = [4, 5, 6]
print(f"{x}")
print(f"{y}")
\end{pycell}
\begin{pyexpectedoutput}
[1, 2, 3]
[4, 5, 6]
\end{pyexpectedoutput}

\chapter{Case with strings and spaces}

\begin{mdcell}
One can print simple strings, possibly containing spaces
\end{mdcell}

\begin{pycell}
x = "one"
y = "two two"
\end{pycell}

\begin{pycell}
z = "three THREE_Three"; n = "FoUr_four quattro_cuatro"
\end{pycell}

\begin{pycell}
" ".join([x, y, z, n])
\end{pycell}
\begin{pyexpectedoutput}
'one two two three THREE_Three FoUr_four quattro_cuatro'
\end{pyexpectedoutput}

\begin{pycell}
print(" ".join([x, y]))
print(" ".join([z, n]))
\end{pycell}
\begin{pyexpectedoutput}
one two two
three THREE_Three FoUr_four quattro_cuatro
\end{pyexpectedoutput}

\begin{mdcell}
One can also print multiline strings
\end{mdcell}

\begin{pycell}
Z = """three
THREE_Three"""
N = """FoUr_four
quattro_cuatro"""
print("\n".join([Z, N]))
\end{pycell}
\begin{pyexpectedoutput}
three
THREE_Three
FoUr_four
quattro_cuatro
\end{pyexpectedoutput}

\begin{pycell}
Z = '''three
THREE_Three'''
N = '''FoUr_four
quattro_cuatro'''
print("\n".join([Z, N]))
\end{pycell}
\begin{pyexpectedoutput}
three
THREE_Three
FoUr_four
quattro_cuatro
\end{pyexpectedoutput}

\chapter{Variable resets}

\begin{mdcell}
In this file the python session resets at every chapter, and therefore
\end{mdcell}

\begin{pycell}
a = 1
b = "this is a string"
print(a, b)
\end{pycell}
\begin{pyexpectedoutput}
1 this is a string
\end{pyexpectedoutput}

\begin{mdcell}
works, but trying to use the variable `x` from the previous chapter would not (see `test_pycell_FAIL.tex`).
\end{mdcell}

\chapter{Figures}

\begin{mdcell}
You can have plotly figures in the code cells. By outputting the figure in the last line of the code cell it will be automatically added to the document.
\end{mdcell}

\begin{pycell}
import plotly.express as px
fig = px.scatter(x=[1, 2, 3], y=[4, 5, 6])
fig
\end{pycell}
\pyexpectedfigure{images/scatter_123_456.png}

\begin{mdcell}
A figure appears also when other text outputs are present
\end{mdcell}

\begin{pycell}
x = [10, 20, 30]
y = [40, 50, 60]
print(f"x = {x}")
print(f"y = {y}")
fig = px.scatter(x=x, y=y)
fig
\end{pycell}
\begin{pyexpectedoutput}
x = [10, 20, 30]
y = [40, 50, 60]
\end{pyexpectedoutput}
\pyexpectedfigure{images/scatter_102030_405060.png}

\chapter{Interacting with the outer document}

\texttt{mdcell} can interact with the rest of the document.

For instance, we can define an equation and a figure before the \texttt{mdcell} call.

\begin{equation}
1 + 1 = 2
\label{eq:1p1e2}
\end{equation}

\begin{figure}
\centering
\includegraphics[width=0.5\linewidth]{images/fail_image_verification.png}
\caption{This is a sample figure with caption}
\label{fig:black}
\end{figure}

Next, we can refer to them inside the \texttt{mdcell} using \verb|`\eqref{...}`{=tex}| and \verb|`\ref{...}`{=tex}| commands.

\begin{mdcell}
We are inside the markdown cell: refer to `\eqref{eq:1p1e2}`{=tex} and to Figure `\ref{fig:black}`{=tex}.
\end{mdcell}

\chapter{Hiding codes}

When \texttt{PythonTeX} is loaded, by providing the optional \texttt{print} argument, some \texttt{pycell} can be executed, included in the output notebook, but hidden from the print.

We first show a cell without the \texttt{print} argument, which defines the variable \texttt{a} ...

\begin{mdcell}
This is a text commenting the definition of the variable `a`. The text will appear in the notebook and in the pdf.
\end{mdcell}
\begin{pycell}
a = 1
\end{pycell}

... then a cell with \texttt{print=true}, which defines the variable \texttt{b} ...

\ifPythonTeXLoaded
\begin{mdcell}[print=true]
This is a text commenting the definition of the variable `b`. The text will appear in the notebook and in the pdf.
\end{mdcell}
\begin{pycell}[print=true]
b = 2
\end{pycell}
\else
\begin{mdcell}
This is a text commenting the definition of the variable `b`. The text will appear in the notebook and in the pdf.
\end{mdcell}
\begin{pycell}
b = 2
\end{pycell}
\fi

... and finally a cell with \texttt{print=false}, which defines the variable \texttt{c} but will not show up in the pdf.

\ifPythonTeXLoaded
\begin{mdcell}[print=false]
This is a text commenting the definition of the variable `c`. The text will appear in the notebook, but not in the pdf.
\end{mdcell}
\begin{pycell}[print=false]
c = 3
\end{pycell}
\else
\fi

The variable \texttt{c} is still available, as we can see by summing \texttt{a + b + c}:
\begin{pycell}
a + b + c
\end{pycell}
\begin{pyexpectedoutput}
6
\end{pyexpectedoutput}

Unfortunately the \texttt{print} optional argument is not supported without \texttt{PythonTeX}.

\chapter{Customizing printing and plotting}

\section{\texttt{numpy} configuration}

\begin{mdcell}
The package internally sets `numpy` printing with the `precision = 3`, `suppress = False`, `edgeitems = 3`, `threshold = 12`. The user can still customize these choices by replacing them with `np.set_printoptions`. Furthermore, it omits types like `np.float64` or `np.int32` while printing the numerical results: this behavior cannot be disabled.
\end{mdcell}

\begin{pycell}
import numpy as np
pi = np.float64(np.pi)
\end{pycell}

\begin{pycell}
pi
\end{pycell}

\begin{pyexpectedoutput}
3.142
\end{pyexpectedoutput}

\begin{pycell}
print(pi)
\end{pycell}

\begin{pyexpectedoutput}
3.142
\end{pyexpectedoutput}

\begin{pycell}
repr(pi)
\end{pycell}

\begin{pyexpectedoutput}
'3.142'
\end{pyexpectedoutput}

\begin{pycell}
pi123 = np.array([pi, 2 * pi, 3 * pi])
\end{pycell}

\begin{pycell}
pi123
\end{pycell}

\begin{pyexpectedoutput}
array([3.142, 6.283, 9.425])
\end{pyexpectedoutput}

\begin{pycell}
print(pi123)
\end{pycell}

\begin{pyexpectedoutput}
[3.142 6.283 9.425]
\end{pyexpectedoutput}

\begin{pycell}
repr(pi123)
\end{pycell}

\begin{pyexpectedoutput}
'array([3.142, 6.283, 9.425])'
\end{pyexpectedoutput}

\section{\texttt{plotly} configuration}

\begin{mdcell}
The package also does the following configuration for `plotly` images:

* The library trims white space from within the image to save space in the LaTeX document: this behavior cannot be configured.
* If width and height are not assigned, a default value of `plotly_default_width = 700`, `plotly_default_height = 500` is assigned. The default value can be changed by modifying `pytex.plotly_default_width` and `pytex.plotly_default_height`.
* Before saving, each dimension of the image is rescaled by a factor `plotly_default_scale = 2`. The default value can be changed by modifying `pytex.plotly_default_scale`.
\end{mdcell}

\begin{mdcell}
We prepare data for the visualization of the function $f(x, y) = x^2 + 2 y^2$ on the domain $D = [-1, 1]^2$.
\end{mdcell}

\begin{pycell}
x_plot = np.linspace(-1, 1, 100)
y_plot = np.linspace(-1, 1, 100)
X_plot, Y_plot = np.meshgrid(x_plot, y_plot)
Z_plot = X_plot**2 + 2 * Y_plot**2
\end{pycell}

\begin{mdcell}
We next import `plotly`. We also add an auxiliary function to change the background to black, so that white space trimming has no effect.
\end{mdcell}

\begin{pycell}
import plotly.graph_objects as go
\end{pycell}

\begin{pycell}
def set_black_background(fig):
    """Set black background to a plotly figure."""
    fig.update_layout(
        paper_bgcolor="black",   # figure background
        plot_bgcolor="black",    # plot area background
        font=dict(color="white") # make text white
    )
\end{pycell}

\begin{pycell}
def check_image_size(image_paths, expected_dimensions):
    """Ensure that the images have the expected dimensions."""
    import PIL.Image
    if len(expected_dimensions) == 2:
        expected_width, expected_height = expected_dimensions
        expected_width_tolerance = 0
        expected_height_tolerance = 0
    else:
        assert len(expected_dimensions) == 4
        (
            expected_width, expected_width_tolerance,
            expected_height, expected_height_tolerance
        ) = expected_dimensions
    for image_path in image_paths:
        img = PIL.Image.open(image_path)
        width, height = img.size
        assert (
            abs(width - expected_width)
            <= expected_width_tolerance
        ), (
            f"Image {image_path} has width "
            f"{width}, but expected width was "
            f"{expected_width} with tolerance "
            f"{expected_width_tolerance}"
        )
        assert (
            abs(height - expected_height)
            <= expected_height_tolerance
        ), (
            f"Image {image_path} has height "
            f"{height}, but expected height was "
            f"{expected_height} with tolerance "
            f"{expected_height_tolerance}"
        )
\end{pycell}

\begin{mdcell}
We save a contour plot using the default width and height.
\end{mdcell}

\begin{pycell}
fig_path = os.path.join(
    f"pythontex-files-{pytex.jobname}",
    f"{pytex.id}_{pytex.instance}.png"
)
fig = go.Figure(data=[go.Contour(x=x_plot, y=y_plot, z=Z_plot)])
fig.update_layout(title="Contour plot")
fig
\end{pycell}
\pyexpectedfigure{images/contour_plot_default_width_height_white_background.png}

\begin{pycell}
check_image_size(
    [
        fig_path,
        os.path.join(
            "images",
            "contour_plot_"
            "default_width_height_"
            "white_background.png"
        )
    ],
    (1223, 4, 740, 4)  # affected by white space trimming
)
\end{pycell}

\begin{pycell}
fig_path = os.path.join(
    f"pythontex-files-{pytex.jobname}",
    f"{pytex.id}_{pytex.instance}.png"
)
fig = go.Figure(data=[go.Contour(x=x_plot, y=y_plot, z=Z_plot)])
fig.update_layout(title="Contour plot")
set_black_background(fig)
fig
\end{pycell}
\pyexpectedfigure{images/contour_plot_default_width_height_black_background.png}

\begin{pycell}
check_image_size(
    [
        fig_path,
        os.path.join(
            "images",
            "contour_plot_"
            "default_width_height_"
            "black_background.png"
        )
    ],
    (1400, 1000)  # default 700 * 500, multiplied by 2
)
\end{pycell}

\begin{mdcell}
We next save a contour plot manually assigning width and height.
\end{mdcell}

\begin{pycell}
fig_path = os.path.join(
    f"pythontex-files-{pytex.jobname}",
    f"{pytex.id}_{pytex.instance}.png"
)
fig = go.Figure(data=[go.Contour(x=x_plot, y=y_plot, z=Z_plot)])
fig.update_layout(
    title="Contour plot", width=512, height=512, autosize=False
)
fig
\end{pycell}
\pyexpectedfigure{images/contour_plot_fixed_width_height_white_background.png}

\begin{pycell}
check_image_size(
    [
        fig_path,
        os.path.join(
            "images",
            "contour_plot_"
            "fixed_width_height_"
            "white_background.png"
        )
    ],
    (855, 4, 764, 4)  # affected by white space trimming
)
\end{pycell}

\begin{pycell}
fig_path = os.path.join(
    f"pythontex-files-{pytex.jobname}",
    f"{pytex.id}_{pytex.instance}.png"
)
fig = go.Figure(data=[go.Contour(x=x_plot, y=y_plot, z=Z_plot)])
fig.update_layout(
    title="Contour plot", width=512, height=512, autosize=False
)
set_black_background(fig)
fig
\end{pycell}
\pyexpectedfigure{images/contour_plot_fixed_width_height_black_background.png}

\begin{pycell}
check_image_size(
    [
        fig_path,
        os.path.join(
            "images",
            "contour_plot_"
            "fixed_width_height_"
            "black_background.png"
        )
    ],
    (1024, 1024)  # assigned 512 * 512, multiplied by 2
)
\end{pycell}

\begin{mdcell}
We finally change the default width, height and scale, and prepare new contour plots.
\end{mdcell}

\begin{pycell}
old_plotly_default_width = pytex.plotly_default_width
pytex.plotly_default_width = 555
old_plotly_default_height = pytex.plotly_default_height
pytex.plotly_default_height = 333
old_plotly_default_scale = pytex.plotly_default_scale
pytex.plotly_default_scale = 3
\end{pycell}

\begin{pycell}
fig_path = os.path.join(
    f"pythontex-files-{pytex.jobname}",
    f"{pytex.id}_{pytex.instance}.png"
)
fig = go.Figure(data=[go.Contour(x=x_plot, y=y_plot, z=Z_plot)])
fig.update_layout(title="Contour plot")
fig
\end{pycell}
\pyexpectedfigure{images/contour_plot_new_default_width_height_white_background.png}

\begin{pycell}
check_image_size(
    [
        fig_path,
        os.path.join(
            "images",
            "contour_plot_"
            "new_default_width_height_"
            "white_background.png"
        )
    ],
    (1396, 4, 608, 4)  # affected by white space trimming
)
\end{pycell}

\begin{pycell}
fig_path = os.path.join(
    f"pythontex-files-{pytex.jobname}",
    f"{pytex.id}_{pytex.instance}.png"
)
fig = go.Figure(data=[go.Contour(x=x_plot, y=y_plot, z=Z_plot)])
fig.update_layout(title="Contour plot")
set_black_background(fig)
fig
\end{pycell}
\pyexpectedfigure{images/contour_plot_new_default_width_height_black_background.png}

\begin{pycell}
check_image_size(
    [
        fig_path,
        os.path.join(
            "images",
            "contour_plot_"
            "new_default_width_height_"
            "black_background.png"
        )
    ],
    (1665, 999)  # default 555 * 333, multiplied by 3
)
\end{pycell}

\begin{mdcell}
We assign the defaults back.
\end{mdcell}

\begin{pycell}
pytex.plotly_default_width = old_plotly_default_width
pytex.plotly_default_height = old_plotly_default_height
pytex.plotly_default_scale = old_plotly_default_scale
\end{pycell}

Notebooks are automatically produced from this chapter, but any cell containing \texttt{pytex} would not be runnable in a plain notebook, because the \texttt{pytex} object is internal. Running the produced notebook is not really the point of this test, hence we simply disable any code cell that includes the words \texttt{pytex} or \texttt{fig\_path}.

\begin{pycell}
original_save_cells_as_notebook = save_cells_as_notebook

def save_cells_as_notebook(
    all_cells: list[tuple[str, str]], pytex: any
) -> None:
    modified_all_cells = []
    for cell in all_cells:
        if cell[0] == "markdown":
            modified_all_cells.append(cell)
        else:
            assert cell[0] == "code"
            if "pytex" in cell[1]:
                code = (
                    "\nprint('This cell was disabled because "
                    "it contains the command pytex')"
                )
            elif "fig_path" in cell[1]:
                code = (
                    "\nprint('This cell was disabled because "
                    "it contains the variable fig_path')"
                )
            else:
                code = cell[1]
            modified_all_cells.append(("code", code))
    return original_save_cells_as_notebook(
        modified_all_cells, pytex
    )
\end{pycell}

\end{document}
